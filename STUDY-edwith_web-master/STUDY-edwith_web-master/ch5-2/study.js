// 정규표현식 
// ^ : 입력의 시작, 다중행 설정을 할 수가 있다.
// $ : 입력의 끝, 다중행 설정을 할 수가 있다.
// * : 앞의 표현식 0회 이상 반복, {0,}와 같은 의미이다.
// + : 앞의 표현식 1회 이상 반복, {1,}와 같은 의미이다.
// ? : 앞의 표현식 0회 또는 1회, {0,1}와 같은 의미이다.
// . : 개행을 제외한 모든 단일 문자와 대응한다.
// (x) : x에 대응하고, 그것을 기억한다.
// (?:x) : x에 대응하고, 그것을 기억하지 않는다.
// x(?=y) : 뒤에 y가 뒤따라오는 x에만 대응한다.
// x(?!y) : 뒤에 y가 뒤따라오지 않는 x에만 대응한다.
// x|y : x또는 y에 대응한다.
// {n} : 앞의 표현식이 n번 나타나는 부분에 대응한다.
// {n,m} : 앞의 표현식이 최소 n번, 최대 m번 나타나는 부분에 대응한다.
// [xyz] : 문자셋, 괄호안의 어떤 문자와도 대응한다.
// [^xyz] : 부정문자셋, 괄호안에 없는 어떤 문자와도 대응한다.
// \b : 단어 경계에 대응한다.
// \B : 단어 경계가 아닌 부분에 대응한다.
// \d : 숫자 문자에 대응한다.
// \D : 숫자 문자가 아닌 부분에 대응한다.
// \n : 줄바꿈 문자에 대응한다.
// \s : 공백 문자에 대응한다.
// \S : 공백 문자가 아닌 문자에 대응한다.
// \w : 단어 문자에 대응한다. [a-zA-Z0-9_]
// \W : 단어 문자가 아닌 문자에 대응한다.

// exec	    대응되는 문자열을 찾는 RegExp 메소드입니다. 정보를 가지고 있는 배열을 반환합니다. 대응되는 문자열을 찾지 못했다면 null을 반환합니다./
// test	    대응되는 문자열이 있는지 검사하는 RegExp 메소드 입니다. true 나 false를 반환합니다.
// match	대응되는 문자열을 찾는 RegExp 메소드입니다. 정보를 가지고 있는 배열을 반환합니다. 대응되는 문자열을 찾지 못했다면 null을 반환합니다.
// search	대응되는  문자열이 있는지 검사하는 String 메소드 입니다. 대응된 부분의 인덱스를 반환합니다. 대응되는 문자열을 찾지 못했다면 -1을 반환합니다.
// replace	대응되는 문자열을 찾아 다른 문자열로 치환하는 String 메소드입니다.
// split	정규식 혹은 문자열로 대상 문자열을 나누어 배열로 반환하는 String 메소드입니다.

"1".match(/1/);
"2".match(/1/);
"a52b52".match(/[0-9]+/);

var target = "test";
var re = /[0-9]+/;
target.match(re);
re.exec(target);

var targets = ["23412", "132-213", "Aadwd", "123-adb"];
var re_post = /^(\d{5}|\d{3}-\d{3})$/
var re_phone = /01[01789]-\d{3,4}-\d{4}/
var result = targets.map((target)=>{
    console.log(target + " " + re.test(target));
    return re_post.test(target);
});
console.log(result);

"011-123-1234".replace(/(\d{2})\d/, "$10");
"$$$iloveyou###".replace(/\W*(\w+)\W*/, "$1")
"231-12312-321-321321-3213-123".match(/\d+/g);
"231-12312-321-321321-3213-123".match(/\d+.*-/);
"231-12312-321-321321-3213-123".match(/\d+.*?-/);